# 3. CrÃ©ation dâ€™un premier serveur

Nous allons maintenant attaquer lâ€™une des parties les plus excitantes et les plus enrichissantes de Node.js : la crÃ©ation de notre propre serveur HTTP.

## 3.1. Un serveur HTTP ?

HTTP est un protocole de rÃ©seau mis au point pour Ã©changer des documents Ã  travers le World Wide Web. Un protocole de rÃ©seau, câ€™est en fait une sÃ©rie de rÃ¨gles qui rÃ©gissent la communication entre plusieurs appareils connectÃ©s. 

HTTP fonctionne suivant ce quâ€™on appelle le **modÃ¨le client-serveur** : un programme, appelÃ© **client** envoie des demandes (appelÃ©es **requÃªtes**), tandis quâ€™un autre programme, appelÃ© **serveur**, est Ã  lâ€™Ã©coute des requÃªtes du client afin de lui envoyer une **rÃ©ponse**.

![Le modÃ¨le client-server](../assets/modele-client-serveur-mini.png)

Un serveur HTTP est donc un programme qui va Ã©couter les requÃªtes des clients et Ã©laborer une rÃ©ponse adÃ©quate.

## 3.2. DÃ©veloppement dâ€™un serveur HTTP

### 3.2.1. CrÃ©er le serveur

```javascript
"use strict";

const http = require("http"); /* RÃ©cupÃ¨re le module http */
const server = http.createServer(); /* CrÃ©e une nouvelle instance de http.Server */

server.listen(8080, () => console.log("Serveur dÃ©marrÃ© !")); /* Ã‰coute le port 8080 */
```

Pour crÃ©er notre serveur, nous allons avoir besoin de quelques fonctionnalitÃ©s de Node.js ! Nous allons donc faire appel au module `http`, qui contient toutes les mÃ©thodes et classes nÃ©cessaires pour manipuler HTTP. Pour importer un module, on utilise la fonction `require`, et nous lui indiquons en argument le nom du module Ã  aller chercher, ici, `http`, que nous stockons dans une variable. 

Nous faisons ensuite appel Ã  la mÃ©thode `createServer()` qui fonctionne comme un constructeur et renvoie une instance de `http.Server`. Nous stockons cette instance dans une variable `server`, et nous appelons la mÃ©thode `listen()`. La mÃ©thode `listen()` indique Ã  notre serveur dâ€™Ã©couter les connexions sur un port en particulier. Nous lui donnons deux arguments : le port Ã  Ã©couter, et un callback Ã  appeler une fois le port mis sous Ã©coute.

#### âž¢ Notion de port

Un port correspond au lieu dâ€™Ã©change entre deux programmes, en lâ€™occurrence un client (navigateur) et un serveur (Node.js), et est identifiÃ© dâ€™aprÃ¨s un petit numÃ©ro. Par dÃ©faut, le numÃ©ro utilisÃ© par HTTP est 80, mais pour du dÃ©veloppement nous utiliserons plutÃ´t 8080. Cela nous Ã©vite des collisions â€“ au cas oÃ¹ le port 80 est dÃ©jÃ  pris â€“ et nous Ã©pargne dâ€™avoir Ã  toucher aux ports systÃ¨me. Les ports systÃ¨me, connus sous le nom de `well-know ports`, sont tous les ports infÃ©rieurs Ã  1024. Ces ports sont rÃ©servÃ©s, vous aurez besoin des privilÃ¨ges administrateurs pour les modifier.

Quelques exemples de ports et de services associÃ©s :

|NumÃ©ro|Programme associÃ©|
|---|---|
|21|serveur FTP|
|25|serveur SMTP|
|53|serveur DNS|
|80|serveur HTTP|
|443|serveur HTTPS|
|2375|Docker|
|3306|MySQL|
|6379|Redis|
|9200|Elasticsearch|
|10823|Farming Simulator 2011|
|25565|Minecraft|

### 3.2.2. Ã‰couter les requÃªtes HTTP

Ajoutez le bout de code suivant Ã  votre script :

```javascript
server.on("request", (request, response) => {
    console.log(request);
    console.log("Jâ€™ai reÃ§u une requÃªte !!!");
});
```

On utilise `on()` pour crÃ©er un nouveau *listener* qui Ã©coute les Ã©vÃ©nements `"request"`. Vous pouvez voir `on()` comme un Ã©quivalent node.js de la mÃ©thode `addEventListener()` ðŸ˜‰

Ã€ chaque fois que notre serveur reÃ§oit une requÃªte, il va dÃ©clencher un callback que nous allons utiliser pour Ã©laborer une rÃ©ponse Ã  cette requÃªte. 

Mais avant toute chose, Ã§a ressemble Ã  quoi, une requÃªte ? Faisons un petit `console.log` de `request` et lanÃ§ons notre code ! Entrez `node server.js` dans votre terminal pour dÃ©marrer le serveur, et ouvrez votre navigateur Ã  lâ€™adresse http://localhost:8080/.

Le navigateur mouline dans le vide, câ€™est normal, nous nâ€™avons actuellement dÃ©fini aucune rÃ©ponse aux requÃªtes. Jetez un Å“il Ã  votre terminal : un trÃ¨Ã¨Ã¨s gros objet est apparu ! Câ€™est en fait notre requÃªte http, parsÃ©e sous forme dâ€™un objet facilement exploitable par JavaScript. Sous forme brute, notre requÃªte ressemblerait Ã  Ã§a :
```
GET / HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
DNT: 1


```
La premiÃ¨re ligne, appelÃ©e *start-line*, nous renseigne sur trois Ã©lÃ©ments importants : 
+ la mÃ©thode : `GET`
+ lâ€™URL de la requÃªte : `/`
+ la version dâ€™HTTP : `HTTP/1.1`

Ce quâ€™on appelle une mÃ©thode HTTP est en fait un petit mot, gÃ©nÃ©ralement un verbe, qui indique lâ€™action Ã  entreprendre par le serveur sur la ressource ciblÃ©e par lâ€™URL. Ici, nous utilisons la mÃ©thode `GET` sur la ressource situÃ©e Ã  lâ€™URL `/`, ce qui revient Ã  demander au serveur lâ€™accÃ¨s Ã  la page dâ€™accueil du site.

Les lignes dâ€™aprÃ¨s sont ce quâ€™on appelle des *headers*, et contiennent des informations sur la requÃªte, comme par exemple le navigateur utilisÃ© ou le systÃ¨me dâ€™exploitation de lâ€™utilisateur.

Finalement, notre requÃªte est terminÃ©e par deux lignes vides : la premiÃ¨re ligne est toujours vide, elle sert de sÃ©parateur entre les headers et ce quâ€™on appelle le *body*, body qui correspond donc Ã  notre seconde ligne. Le body contient habituellement les donnÃ©es jointes Ã  la requÃªte, par exemple celles dâ€™un formulaire lors de son envoi. Ici, il sâ€™agit dâ€™une simple requÃªte GET, nous nâ€™avons aucune donnÃ©e Ã  envoyer, le body est donc vide.

Essayons dâ€™accÃ©der Ã  ces informations depuis lâ€™objet `request` de Node.js ! Ã‰ditez votre code pour quâ€™il corresponde au snippet ci-dessous, relancez votre script (`Ctrl` + `C` puis `node server.js`) et retournez Ã  lâ€™adresse http://localhost:8080/.
```javascript
server.on("request", (request, response) => {
    console.log("url: " + request.url);
    console.log("method: " + request.method);
    console.log(request.headers);
});
```
Vous devriez obtenir quelque chose de ce genre :
```
url: /
method: GET
{
  host: 'localhost:8080',
  'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0',
  accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
  'accept-language': 'fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3',
  'accept-encoding': 'gzip, deflate',
  connection: 'keep-alive',
  'upgrade-insecure-requests': '1',
  dnt: '1'
}
```

Cool ! Nous savons maintenant comment accÃ©der aux informations de notre requÃªte ðŸ¥³

Dans la prochaine partie, nous nous pencherons sur lâ€™Ã©laboration dâ€™une rÃ©ponse.

**NEXT âŸ¹ [4. 4. RÃ©ponse du serveur au client](./4.%20RÃ©ponse%20du%20serveur%20au%20client.md)**